import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/css-in-js-utils/lib/isPrefixedValue.js
var require_isPrefixedValue = __commonJS({
  "node_modules/css-in-js-utils/lib/isPrefixedValue.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPrefixedValue6;
    var regex = /-webkit-|-moz-|-ms-/;
    function isPrefixedValue6(value) {
      return typeof value === "string" && regex.test(value);
    }
    module.exports = exports["default"];
  }
});

// node_modules/hyphenate-style-name/index.js
var hyphenate_style_name_exports = {};
__export(hyphenate_style_name_exports, {
  default: () => hyphenate_style_name_default
});
function toHyphenLower(match) {
  return "-" + match.toLowerCase();
}
function hyphenateStyleName2(name) {
  if (cache2.hasOwnProperty(name)) {
    return cache2[name];
  }
  var hName = name.replace(uppercasePattern2, toHyphenLower);
  return cache2[name] = msPattern2.test(hName) ? "-" + hName : hName;
}
var uppercasePattern2, msPattern2, cache2, hyphenate_style_name_default;
var init_hyphenate_style_name = __esm({
  "node_modules/hyphenate-style-name/index.js"() {
    uppercasePattern2 = /[A-Z]/g;
    msPattern2 = /^ms-/;
    cache2 = {};
    hyphenate_style_name_default = hyphenateStyleName2;
  }
});

// node_modules/css-in-js-utils/lib/hyphenateProperty.js
var require_hyphenateProperty = __commonJS({
  "node_modules/css-in-js-utils/lib/hyphenateProperty.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = hyphenateProperty2;
    var _hyphenateStyleName = (init_hyphenate_style_name(), __toCommonJS(hyphenate_style_name_exports));
    var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function hyphenateProperty2(property) {
      return (0, _hyphenateStyleName2.default)(property);
    }
    module.exports = exports["default"];
  }
});

// node_modules/styletron-engine-monolithic/dist-browser-esm/client/sheet.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (let i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  const tag = document.createElement("style");
  if (typeof options.nonce !== "undefined") {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  return tag;
}
var StyleSheet = class {
  constructor(options) {
    this.isSpeedy = typeof options.speedy === "undefined" ? false : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.container = options.container;
    this.before = null;
  }
  insert(rules) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      const tag2 = createStyleElement(this);
      let before;
      if (this.tags.length === 0) {
        before = this.before;
      } else {
        before = this.tags[this.tags.length - 1].nextSibling;
      }
      this.container.insertBefore(tag2, before);
      this.tags.push(tag2);
    }
    const tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      const sheet = sheetForTag(tag);
      rules.forEach((rule) => {
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
          if (true) {
            console.warn(`There was a problem inserting the following rule: "${rule}"`, e);
          }
        }
      });
    } else {
      tag.appendChild(document.createTextNode(rules.join("")));
    }
    this.ctr++;
  }
  flush() {
    this.tags.forEach((tag) => tag.parentNode.removeChild(tag));
    this.tags = [];
    this.ctr = 0;
  }
};

// node_modules/styletron-engine-monolithic/dist-browser-esm/hyphenate-style-name.js
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};
function hyphenateStyleName(prop) {
  return prop in cache ? cache[prop] : cache[prop] = prop.replace(uppercasePattern, "-$&").toLowerCase().replace(msPattern, "-ms-");
}

// node_modules/styletron-engine-monolithic/dist-browser-esm/validate-no-mixed-hand.js
var shorthandMap = {
  // CSS 2.1: https://www.w3.org/TR/CSS2/propidx.html
  "list-style": ["list-style-type", "list-style-position", "list-style-image"],
  margin: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
  outline: ["outline-width", "outline-style", "outline-color"],
  padding: ["padding-top", "padding-right", "padding-bottom", "padding-left"],
  // CSS Backgrounds and Borders Module Level 3: https://www.w3.org/TR/css3-background/
  background: ["background-image", "background-position", "background-size", "background-repeat", "background-origin", "background-clip", "background-attachment", "background-color"],
  border: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-width", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-style", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-color"],
  "border-color": ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"],
  "border-style": ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"],
  "border-width": ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
  "border-top": ["border-top-width", "border-top-style", "border-top-color"],
  "border-right": ["border-right-width", "border-right-style", "border-right-color"],
  "border-bottom": ["border-bottom-width", "border-bottom-style", "border-bottom-color"],
  "border-left": ["border-left-width", "border-left-style", "border-left-color"],
  "border-radius": ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"],
  "border-image": ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"],
  // CSS Fonts Module Level 3: https://www.w3.org/TR/css3-fonts/
  font: ["font-style", "font-variant-ligatures", "font-variant-alternates", "font-variant-caps", "font-variant-numeric", "font-variant-east-asian", "font-variant", "font-weight", "font-stretch", "font-size", "line-height", "font-family"],
  "font-variant": ["font-variant-ligatures", "font-variant-alternates", "font-variant-caps", "font-variant-numeric", "font-variant-east-asian"],
  // CSS Flexible Box Layout Module Level 1: https://www.w3.org/TR/css3-flexbox-1/
  flex: ["flex-grow", "flex-shrink", "flex-basis"],
  "flex-flow": ["flex-direction", "flex-wrap"],
  // CSS Grid Layout Module Level 1: https://www.w3.org/TR/css-grid-1/
  grid: ["grid-template-rows", "grid-template-columns", "grid-template-areas", "grid-auto-rows", "grid-auto-columns", "grid-auto-flow"],
  "grid-template": ["grid-template-rows", "grid-template-columns", "grid-template-areas"],
  "grid-row": ["grid-row-start", "grid-row-end"],
  "grid-column": ["grid-column-start", "grid-column-end"],
  "grid-area": ["grid-row-start", "grid-column-start", "grid-row-end", "grid-column-end"],
  "grid-gap": ["grid-row-gap", "grid-column-gap"],
  // CSS Masking Module Level 1: https://www.w3.org/TR/css-masking/
  mask: ["mask-image", "mask-mode", "mask-position", "mask-size", "mask-repeat", "mask-origin", "mask-clip"],
  "mask-border": ["mask-border-source", "mask-border-slice", "mask-border-width", "mask-border-outset", "mask-border-repeat", "mask-border-mode"],
  // CSS Multi-column Layout Module: https://www.w3.org/TR/css3-multicol/
  columns: ["column-width", "column-count"],
  "column-rule": ["column-rule-width", "column-rule-style", "column-rule-color"],
  // CSS Scroll Snap Module Level 1: https://www.w3.org/TR/css-scroll-snap-1/
  "scroll-padding": ["scroll-padding-top", "scroll-padding-right", "scroll-padding-bottom", "scroll-padding-left"],
  "scroll-padding-block": ["scroll-padding-block-start", "scroll-padding-block-end"],
  "scroll-padding-inline": ["scroll-padding-inline-start", "scroll-padding-inline-end"],
  "scroll-snap-margin": ["scroll-snap-margin-top", "scroll-snap-margin-right", "scroll-snap-margin-bottom", "scroll-snap-margin-left"],
  "scroll-snap-margin-block": ["scroll-snap-margin-block-start", "scroll-snap-margin-block-end"],
  "scroll-snap-margin-inline": ["scroll-snap-margin-inline-start", "scroll-snap-margin-inline-end"],
  // CSS Speech Module: https://www.w3.org/TR/css3-speech/
  cue: ["cue-before", "cue-after"],
  pause: ["pause-before", "pause-after"],
  rest: ["rest-before", "rest-after"],
  // CSS Text Decoration Module Level 3: https://www.w3.org/TR/css-text-decor-3/
  "text-decoration": ["text-decoration-line", "text-decoration-style", "text-decoration-color"],
  "text-emphasis": ["text-emphasis-style", "text-emphasis-color"],
  // CSS Animations (WD): https://www.w3.org/TR/css3-animations
  animation: ["animation-name", "animation-duration", "animation-timing-function", "animation-delay", "animation-iteration-count", "animation-direction", "animation-fill-mode", "animation-play-state"],
  // CSS Transitions (WD): https://www.w3.org/TR/css3-transitions/
  transition: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay"]
};
function validateNoMixedHand(style) {
  const hyphenatedProperties = Object.keys(style).reduce((acc, property) => {
    acc[hyphenateStyleName(property)] = property;
    return acc;
  }, {});
  const mixed = [];
  for (const property in hyphenatedProperties) {
    if (property in shorthandMap) {
      for (const longhand of shorthandMap[property]) {
        if (longhand in hyphenatedProperties) {
          const long = hyphenatedProperties[longhand];
          const short = hyphenatedProperties[property];
          mixed.push({
            shorthand: {
              property: short,
              value: style[short]
            },
            longhand: {
              property: long,
              value: style[long]
            }
          });
        }
      }
    }
  }
  return mixed;
}

// node_modules/inline-style-prefixer/es/utils/capitalizeString.js
function capitalizeString(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// node_modules/inline-style-prefixer/es/utils/prefixProperty.js
function prefixProperty(prefixProperties, property, style) {
  if (prefixProperties.hasOwnProperty(property)) {
    var newStyle = {};
    var requiredPrefixes = prefixProperties[property];
    var capitalizedProperty = capitalizeString(property);
    var keys = Object.keys(style);
    for (var i = 0; i < keys.length; i++) {
      var styleProperty = keys[i];
      if (styleProperty === property) {
        for (var j = 0; j < requiredPrefixes.length; j++) {
          newStyle[requiredPrefixes[j] + capitalizedProperty] = style[property];
        }
      }
      newStyle[styleProperty] = style[styleProperty];
    }
    return newStyle;
  }
  return style;
}

// node_modules/inline-style-prefixer/es/utils/prefixValue.js
function prefixValue(plugins2, property, value, style, metaData) {
  for (var i = 0, len = plugins2.length; i < len; ++i) {
    var processedValue = plugins2[i](property, value, style, metaData);
    if (processedValue) {
      return processedValue;
    }
  }
}

// node_modules/inline-style-prefixer/es/utils/addNewValuesOnly.js
function addIfNew(list, value) {
  if (list.indexOf(value) === -1) {
    list.push(value);
  }
}
function addNewValuesOnly(list, values5) {
  if (Array.isArray(values5)) {
    for (var i = 0, len = values5.length; i < len; ++i) {
      addIfNew(list, values5[i]);
    }
  } else {
    addIfNew(list, values5);
  }
}

// node_modules/inline-style-prefixer/es/utils/isObject.js
function isObject(value) {
  return value instanceof Object && !Array.isArray(value);
}

// node_modules/inline-style-prefixer/es/createPrefixer.js
function createPrefixer(_ref) {
  var prefixMap = _ref.prefixMap, plugins2 = _ref.plugins;
  return function prefix2(style) {
    for (var property in style) {
      var value = style[property];
      if (isObject(value)) {
        style[property] = prefix2(value);
      } else if (Array.isArray(value)) {
        var combinedValue = [];
        for (var i = 0, len = value.length; i < len; ++i) {
          var processedValue = prefixValue(plugins2, property, value[i], style, prefixMap);
          addNewValuesOnly(combinedValue, processedValue || value[i]);
        }
        if (combinedValue.length > 0) {
          style[property] = combinedValue;
        }
      } else {
        var _processedValue = prefixValue(plugins2, property, value, style, prefixMap);
        if (_processedValue) {
          style[property] = _processedValue;
        }
        style = prefixProperty(prefixMap, property, style);
      }
    }
    return style;
  };
}

// node_modules/inline-style-prefixer/es/data.js
var w = ["Webkit"];
var m = ["Moz"];
var ms = ["ms"];
var wm = ["Webkit", "Moz"];
var wms = ["Webkit", "ms"];
var wmms = ["Webkit", "Moz", "ms"];
var data_default = {
  plugins: [],
  prefixMap: { "appearance": wm, "textEmphasisPosition": w, "textEmphasis": w, "textEmphasisStyle": w, "textEmphasisColor": w, "boxDecorationBreak": w, "maskImage": w, "maskMode": w, "maskRepeat": w, "maskPosition": w, "maskClip": w, "maskOrigin": w, "maskSize": w, "maskComposite": w, "mask": w, "maskBorderSource": w, "maskBorderMode": w, "maskBorderSlice": w, "maskBorderWidth": w, "maskBorderOutset": w, "maskBorderRepeat": w, "maskBorder": w, "maskType": w, "textDecorationStyle": w, "textDecorationSkip": w, "textDecorationLine": w, "textDecorationColor": w, "userSelect": wmms, "backdropFilter": w, "fontKerning": w, "scrollSnapType": wms, "scrollSnapPointsX": wms, "scrollSnapPointsY": wms, "scrollSnapDestination": wms, "scrollSnapCoordinate": wms, "clipPath": w, "shapeImageThreshold": w, "shapeImageMargin": w, "shapeImageOutside": w, "filter": w, "hyphens": wms, "flowInto": wms, "flowFrom": wms, "breakBefore": wms, "breakAfter": wms, "breakInside": wms, "regionFragment": wms, "writingMode": wms, "textOrientation": w, "tabSize": m, "fontFeatureSettings": w, "columnCount": w, "columnFill": w, "columnGap": w, "columnRule": w, "columnRuleColor": w, "columnRuleStyle": w, "columnRuleWidth": w, "columns": w, "columnSpan": w, "columnWidth": w, "wrapFlow": ms, "wrapThrough": ms, "wrapMargin": ms, "textSizeAdjust": wms }
};

// node_modules/inline-style-prefixer/es/plugins/backgroundClip.js
function backgroundClip(property, value) {
  if (typeof value === "string" && value === "text") {
    return ["-webkit-text", "text"];
  }
}

// node_modules/inline-style-prefixer/es/plugins/cursor.js
var prefixes = ["-webkit-", "-moz-", ""];
var values = {
  "zoom-in": true,
  "zoom-out": true,
  grab: true,
  grabbing: true
};
function cursor(property, value) {
  if (property === "cursor" && values.hasOwnProperty(value)) {
    return prefixes.map(function(prefix2) {
      return prefix2 + value;
    });
  }
}

// node_modules/inline-style-prefixer/es/plugins/crossFade.js
var import_isPrefixedValue = __toESM(require_isPrefixedValue());
var prefixes2 = ["-webkit-", ""];
function crossFade(property, value) {
  if (typeof value === "string" && !(0, import_isPrefixedValue.default)(value) && value.indexOf("cross-fade(") > -1) {
    return prefixes2.map(function(prefix2) {
      return value.replace(/cross-fade\(/g, prefix2 + "cross-fade(");
    });
  }
}

// node_modules/inline-style-prefixer/es/plugins/filter.js
var import_isPrefixedValue2 = __toESM(require_isPrefixedValue());
var prefixes3 = ["-webkit-", ""];
function filter(property, value) {
  if (typeof value === "string" && !(0, import_isPrefixedValue2.default)(value) && value.indexOf("filter(") > -1) {
    return prefixes3.map(function(prefix2) {
      return value.replace(/filter\(/g, prefix2 + "filter(");
    });
  }
}

// node_modules/inline-style-prefixer/es/plugins/flex.js
var values2 = {
  flex: ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex", "flex"],
  "inline-flex": ["-webkit-inline-box", "-moz-inline-box", "-ms-inline-flexbox", "-webkit-inline-flex", "inline-flex"]
};
function flex(property, value) {
  if (property === "display" && values2.hasOwnProperty(value)) {
    return values2[value];
  }
}

// node_modules/inline-style-prefixer/es/plugins/flexboxOld.js
var alternativeValues = {
  "space-around": "justify",
  "space-between": "justify",
  "flex-start": "start",
  "flex-end": "end",
  "wrap-reverse": "multiple",
  wrap: "multiple"
};
var alternativeProps = {
  alignItems: "WebkitBoxAlign",
  justifyContent: "WebkitBoxPack",
  flexWrap: "WebkitBoxLines",
  flexGrow: "WebkitBoxFlex"
};
function flexboxOld(property, value, style) {
  if (property === "flexDirection" && typeof value === "string") {
    if (value.indexOf("column") > -1) {
      style.WebkitBoxOrient = "vertical";
    } else {
      style.WebkitBoxOrient = "horizontal";
    }
    if (value.indexOf("reverse") > -1) {
      style.WebkitBoxDirection = "reverse";
    } else {
      style.WebkitBoxDirection = "normal";
    }
  }
  if (alternativeProps.hasOwnProperty(property)) {
    style[alternativeProps[property]] = alternativeValues[value] || value;
  }
}

// node_modules/inline-style-prefixer/es/plugins/gradient.js
var import_isPrefixedValue3 = __toESM(require_isPrefixedValue());
var prefixes4 = ["-webkit-", "-moz-", ""];
var values3 = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/gi;
function gradient(property, value) {
  if (typeof value === "string" && !(0, import_isPrefixedValue3.default)(value) && values3.test(value)) {
    return prefixes4.map(function(prefix2) {
      return value.replace(values3, function(grad) {
        return prefix2 + grad;
      });
    });
  }
}

// node_modules/inline-style-prefixer/es/plugins/grid.js
var _slicedToArray = /* @__PURE__ */ (function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
})();
function isSimplePositionValue(value) {
  return typeof value === "number" && !isNaN(value);
}
function isComplexSpanValue(value) {
  return typeof value === "string" && value.includes("/");
}
var alignmentValues = ["center", "end", "start", "stretch"];
var displayValues = {
  "inline-grid": ["-ms-inline-grid", "inline-grid"],
  grid: ["-ms-grid", "grid"]
};
var propertyConverters = {
  alignSelf: function alignSelf(value, style) {
    if (alignmentValues.indexOf(value) > -1) {
      style.msGridRowAlign = value;
    }
  },
  gridColumn: function gridColumn(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridColumn = value;
    } else if (isComplexSpanValue(value)) {
      var _value$split = value.split("/"), _value$split2 = _slicedToArray(_value$split, 2), start = _value$split2[0], end = _value$split2[1];
      propertyConverters.gridColumnStart(+start, style);
      var _end$split = end.split(/ ?span /), _end$split2 = _slicedToArray(_end$split, 2), maybeSpan = _end$split2[0], maybeNumber = _end$split2[1];
      if (maybeSpan === "") {
        propertyConverters.gridColumnEnd(+start + +maybeNumber, style);
      } else {
        propertyConverters.gridColumnEnd(+end, style);
      }
    } else {
      propertyConverters.gridColumnStart(value, style);
    }
  },
  gridColumnEnd: function gridColumnEnd(value, style) {
    var msGridColumn = style.msGridColumn;
    if (isSimplePositionValue(value) && isSimplePositionValue(msGridColumn)) {
      style.msGridColumnSpan = value - msGridColumn;
    }
  },
  gridColumnStart: function gridColumnStart(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridColumn = value;
    }
  },
  gridRow: function gridRow(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridRow = value;
    } else if (isComplexSpanValue(value)) {
      var _value$split3 = value.split("/"), _value$split4 = _slicedToArray(_value$split3, 2), start = _value$split4[0], end = _value$split4[1];
      propertyConverters.gridRowStart(+start, style);
      var _end$split3 = end.split(/ ?span /), _end$split4 = _slicedToArray(_end$split3, 2), maybeSpan = _end$split4[0], maybeNumber = _end$split4[1];
      if (maybeSpan === "") {
        propertyConverters.gridRowEnd(+start + +maybeNumber, style);
      } else {
        propertyConverters.gridRowEnd(+end, style);
      }
    } else {
      propertyConverters.gridRowStart(value, style);
    }
  },
  gridRowEnd: function gridRowEnd(value, style) {
    var msGridRow = style.msGridRow;
    if (isSimplePositionValue(value) && isSimplePositionValue(msGridRow)) {
      style.msGridRowSpan = value - msGridRow;
    }
  },
  gridRowStart: function gridRowStart(value, style) {
    if (isSimplePositionValue(value)) {
      style.msGridRow = value;
    }
  },
  gridTemplateColumns: function gridTemplateColumns(value, style) {
    style.msGridColumns = value;
  },
  gridTemplateRows: function gridTemplateRows(value, style) {
    style.msGridRows = value;
  },
  justifySelf: function justifySelf(value, style) {
    if (alignmentValues.indexOf(value) > -1) {
      style.msGridColumnAlign = value;
    }
  }
};
function grid(property, value, style) {
  if (property === "display" && value in displayValues) {
    return displayValues[value];
  }
  if (property in propertyConverters) {
    var propertyConverter = propertyConverters[property];
    propertyConverter(value, style);
  }
}

// node_modules/inline-style-prefixer/es/plugins/imageSet.js
var import_isPrefixedValue4 = __toESM(require_isPrefixedValue());
var prefixes5 = ["-webkit-", ""];
function imageSet(property, value) {
  if (typeof value === "string" && !(0, import_isPrefixedValue4.default)(value) && value.indexOf("image-set(") > -1) {
    return prefixes5.map(function(prefix2) {
      return value.replace(/image-set\(/g, prefix2 + "image-set(");
    });
  }
}

// node_modules/inline-style-prefixer/es/plugins/logical.js
var alternativeProps2 = {
  marginBlockStart: ["WebkitMarginBefore"],
  marginBlockEnd: ["WebkitMarginAfter"],
  marginInlineStart: ["WebkitMarginStart", "MozMarginStart"],
  marginInlineEnd: ["WebkitMarginEnd", "MozMarginEnd"],
  paddingBlockStart: ["WebkitPaddingBefore"],
  paddingBlockEnd: ["WebkitPaddingAfter"],
  paddingInlineStart: ["WebkitPaddingStart", "MozPaddingStart"],
  paddingInlineEnd: ["WebkitPaddingEnd", "MozPaddingEnd"],
  borderBlockStart: ["WebkitBorderBefore"],
  borderBlockStartColor: ["WebkitBorderBeforeColor"],
  borderBlockStartStyle: ["WebkitBorderBeforeStyle"],
  borderBlockStartWidth: ["WebkitBorderBeforeWidth"],
  borderBlockEnd: ["WebkitBorderAfter"],
  borderBlockEndColor: ["WebkitBorderAfterColor"],
  borderBlockEndStyle: ["WebkitBorderAfterStyle"],
  borderBlockEndWidth: ["WebkitBorderAfterWidth"],
  borderInlineStart: ["WebkitBorderStart", "MozBorderStart"],
  borderInlineStartColor: ["WebkitBorderStartColor", "MozBorderStartColor"],
  borderInlineStartStyle: ["WebkitBorderStartStyle", "MozBorderStartStyle"],
  borderInlineStartWidth: ["WebkitBorderStartWidth", "MozBorderStartWidth"],
  borderInlineEnd: ["WebkitBorderEnd", "MozBorderEnd"],
  borderInlineEndColor: ["WebkitBorderEndColor", "MozBorderEndColor"],
  borderInlineEndStyle: ["WebkitBorderEndStyle", "MozBorderEndStyle"],
  borderInlineEndWidth: ["WebkitBorderEndWidth", "MozBorderEndWidth"]
};
function logical(property, value, style) {
  if (Object.prototype.hasOwnProperty.call(alternativeProps2, property)) {
    var alternativePropList = alternativeProps2[property];
    for (var i = 0, len = alternativePropList.length; i < len; ++i) {
      style[alternativePropList[i]] = value;
    }
  }
}

// node_modules/inline-style-prefixer/es/plugins/position.js
function position(property, value) {
  if (property === "position" && value === "sticky") {
    return ["-webkit-sticky", "sticky"];
  }
}

// node_modules/inline-style-prefixer/es/plugins/sizing.js
var prefixes6 = ["-webkit-", "-moz-", ""];
var properties = {
  maxHeight: true,
  maxWidth: true,
  width: true,
  height: true,
  columnWidth: true,
  minWidth: true,
  minHeight: true
};
var values4 = {
  "min-content": true,
  "max-content": true,
  "fill-available": true,
  "fit-content": true,
  "contain-floats": true
};
function sizing(property, value) {
  if (properties.hasOwnProperty(property) && values4.hasOwnProperty(value)) {
    return prefixes6.map(function(prefix2) {
      return prefix2 + value;
    });
  }
}

// node_modules/inline-style-prefixer/es/plugins/transition.js
var import_hyphenateProperty = __toESM(require_hyphenateProperty());
var import_isPrefixedValue5 = __toESM(require_isPrefixedValue());
var properties2 = {
  transition: true,
  transitionProperty: true,
  WebkitTransition: true,
  WebkitTransitionProperty: true,
  MozTransition: true,
  MozTransitionProperty: true
};
var prefixMapping = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  ms: "-ms-"
};
function prefixValue2(value, propertyPrefixMap) {
  if ((0, import_isPrefixedValue5.default)(value)) {
    return value;
  }
  var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
  for (var i = 0, len = multipleValues.length; i < len; ++i) {
    var singleValue = multipleValues[i];
    var values5 = [singleValue];
    for (var property in propertyPrefixMap) {
      var dashCaseProperty = (0, import_hyphenateProperty.default)(property);
      if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== "order") {
        var prefixes7 = propertyPrefixMap[property];
        for (var j = 0, pLen = prefixes7.length; j < pLen; ++j) {
          values5.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes7[j]] + dashCaseProperty));
        }
      }
    }
    multipleValues[i] = values5.join(",");
  }
  return multipleValues.join(",");
}
function transition(property, value, style, propertyPrefixMap) {
  if (typeof value === "string" && properties2.hasOwnProperty(property)) {
    var outputValue = prefixValue2(value, propertyPrefixMap);
    var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
      return !/-moz-|-ms-/.test(val);
    }).join(",");
    if (property.indexOf("Webkit") > -1) {
      return webkitOutput;
    }
    var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
      return !/-webkit-|-ms-/.test(val);
    }).join(",");
    if (property.indexOf("Moz") > -1) {
      return mozOutput;
    }
    style["Webkit" + capitalizeString(property)] = webkitOutput;
    style["Moz" + capitalizeString(property)] = mozOutput;
    return outputValue;
  }
}

// node_modules/inline-style-prefixer/es/index.js
var plugins = [backgroundClip, crossFade, cursor, filter, flexboxOld, gradient, grid, imageSet, logical, position, sizing, transition, flex];
var prefix = createPrefixer({
  prefixMap: data_default.prefixMap,
  plugins
});

// node_modules/styletron-engine-monolithic/dist-browser-esm/inject-style-prefixed.js
function injectStylePrefixed(styles, selector, prefix2, strict) {
  let rules = "";
  let classes = [];
  for (const key in styles) {
    const value = styles[key];
    if (value === void 0 || value === null) {
      continue;
    }
    if (typeof value !== "object") {
      if (true) {
        if (value === null || Array.isArray(value) || typeof value !== "number" && typeof value !== "string") {
          throw new Error(`Unsupported style value: ${JSON.stringify(value)} used in property ${JSON.stringify(key)}`);
        }
      }
      const rule = hyphenateStyleName(key) + ":" + value;
      const prefixed = prefix({
        [key]: value
      });
      for (const prefixedKey in prefixed) {
        const prefixedVal = prefixed[prefixedKey];
        if (typeof prefixedVal === "string" || typeof prefixedVal === "number") {
          const prefixedRule = hyphenateStyleName(prefixedKey) + ":" + prefixedVal;
          if (prefixedRule !== rule) {
            rules += prefixedRule + ";";
          }
        } else if (Array.isArray(prefixedVal)) {
          const hyphenated = hyphenateStyleName(prefixedKey);
          for (let i = 0; i < prefixedVal.length; i++) {
            const prefixedRule = hyphenated + ":" + prefixedVal[i];
            if (prefixedRule !== rule) {
              rules += prefixedRule + ";";
            }
          }
        }
      }
      rules += rule + ";";
      continue;
    }
    if (key[0] === ":") {
      classes = [...classes, ...injectStylePrefixed(value, selector + key, prefix2, strict)];
      continue;
    }
    if (key[0] === "@") {
      const nestedRules = injectStylePrefixed(value, selector, prefix2, strict);
      classes = [...classes, key + "{" + nestedRules.join("") + "}"];
      continue;
    }
    classes = [...classes, key + "{" + injectStylePrefixed(value, "", prefix2, strict).join("") + "}"];
  }
  if (strict && true) {
    const conflicts = validateNoMixedHand(styles);
    if (conflicts.length) {
      conflicts.forEach(({
        shorthand,
        longhand
      }) => {
        const short = JSON.stringify({
          [shorthand.property]: shorthand.value
        });
        const long = JSON.stringify({
          [longhand.property]: longhand.value
        });
        console.warn(`Styles \`${short}\` and \`${long}\` in object yielding class "${selector}" may result in unexpected behavior. Mixing shorthand and longhand properties within the same style object is unsupported with atomic rendering.`);
      });
    }
  }
  if (!selector) {
    return [rules];
  }
  const result = [];
  if (rules) {
    result.push(`.${prefix2}css-${selector}{${rules}}`);
  }
  return [...result, ...classes];
}

// node_modules/styletron-engine-monolithic/dist-browser-esm/validate-keyframes-object.js
var validAnimationState = /^(from|to|\+?(\d*\.)?\d+%)(\s*,\s*(from|to|\+?(\d*\.)?\d+%))*$/;
function validateKeyframesObject(keyframes) {
  let valid = true;
  for (const animationState in keyframes) {
    const value = keyframes[animationState];
    if (!validAnimationState.test(animationState)) {
      valid = false;
      console.warn(`Warning: property "${animationState}" in keyframes object ${JSON.stringify(keyframes)} is not a valid. Must be "from", "to", or a percentage.`);
    }
    if (typeof value !== "object") {
      valid = false;
      console.warn(`Warning: value for "${animationState}" property in keyframes object ${JSON.stringify(keyframes)} must be an object. Instead it was a ${typeof value}.`);
    }
    if (!valid) {
      console.warn(`Warning: object used as value for "animationName" style is invalid:`, keyframes);
    }
  }
}

// node_modules/styletron-engine-monolithic/dist-browser-esm/generate-alphabetic-name.js
var AD_REPLACER_R = /(a)(d)/gi;
var charsLength = 52;
var getAlphabeticChar = (code) => String.fromCharCode(code + (code > 25 ? 39 : 97));
function generateAlphabeticName(code) {
  let name = "";
  let x;
  for (x = Math.abs(code); x > charsLength; x = x / charsLength | 0) {
    name = getAlphabeticChar(x % charsLength) + name;
  }
  return (getAlphabeticChar(x % charsLength) + name).replace(AD_REPLACER_R, "$1-$2");
}

// node_modules/styletron-engine-monolithic/dist-browser-esm/hash.js
var SEED = 5381 | 0;
var phash = (h, x) => {
  h |= 0;
  for (let i = 0, l = x.length | 0; i < l; i++) {
    h = (h << 5) + h + x.charCodeAt(i);
  }
  return h;
};
var hash = (x) => {
  return phash(SEED, x) >>> 0;
};

// node_modules/styletron-engine-monolithic/dist-browser-esm/css.js
function hashCssObject(cssObject) {
  return generateAlphabeticName(hash(JSON.stringify(cssObject)));
}
function keyframesToBlock(keyframes) {
  if (true) {
    validateKeyframesObject(keyframes);
  }
  if (typeof Object.getPrototypeOf(keyframes) !== "undefined") {
    if (Object.getPrototypeOf(keyframes) !== Object.getPrototypeOf({})) {
      console.warn("Only plain objects should be used as animation values. Unexpectedly recieved:", keyframes);
    }
  }
  let result = "";
  for (const animationState in keyframes) {
    result += `${animationState}{${declarationsToBlock(keyframes[animationState])}}`;
  }
  return result;
}
function declarationsToBlock(style) {
  let css = "";
  for (const prop in style) {
    const val = style[prop];
    if (typeof val === "string" || typeof val === "number") {
      css += `${hyphenateStyleName(prop)}:${val};`;
    }
  }
  return css.slice(0, -1);
}
function keyframesBlockToRule(id, block) {
  return `@keyframes ${id}{${block}}`;
}
function fontFaceBlockToRule(id, block) {
  return `@font-face{font-family:${id};${block}}`;
}

// node_modules/styletron-engine-monolithic/dist-browser-esm/client/client.js
var StyletronClient = class {
  constructor(opts = {}) {
    this.opts = opts || {};
    this.cache = {};
    if (opts.container) {
      this.container = opts.container;
    }
    if (opts.hydrate && opts.hydrate.length > 1) {
      if (true) {
        console.warn("Client hydration expects only a single style tag from the server. Make sure your server uses styletron-engine-monolithic and not atomic.");
      }
    } else if (opts.hydrate && opts.hydrate.length === 1) {
      if (!this.container) {
        const parentElement = opts.hydrate[0].parentElement;
        if (parentElement !== null && parentElement !== void 0) {
          this.container = parentElement;
        }
      }
      const element = opts.hydrate[0];
      const dataHydrate = element.getAttribute("data-hydrate");
      if (dataHydrate) {
        dataHydrate.split(" ").forEach((hashKey) => {
          this.cache[hashKey] = true;
        });
      }
    }
    if (!this.container) {
      if (document.head === null) {
        throw new Error("No container provided and `document.head` was null");
      }
      this.container = document.head;
    }
    this.styleSheet = new StyleSheet({
      container: this.container,
      speedy: this.opts.speedy
    });
  }
  renderStyle(styles) {
    const className = hashCssObject(styles);
    if (!this.cache[className]) {
      this.cache[className] = true;
      this.styleSheet.insert(injectStylePrefixed(styles, className, this.opts.prefix || "", Boolean(this.opts.strict)));
    }
    return `${this.opts.prefix || ""}css-${className}`;
  }
  renderFontFace(fontFace) {
    const fontName = hashCssObject(fontFace);
    if (!this.cache[fontName]) {
      this.cache[fontName] = true;
      this.styleSheet.insert([fontFaceBlockToRule(`${this.opts.prefix || ""}font-${fontName}`, declarationsToBlock(fontFace))]);
    }
    return `${this.opts.prefix || ""}font-${fontName}`;
  }
  renderKeyframes(keyframes) {
    const animationName = hashCssObject(keyframes);
    if (!this.cache[animationName]) {
      this.cache[animationName] = true;
      this.styleSheet.insert([keyframesBlockToRule(`${this.opts.prefix || ""}animation-${animationName}`, keyframesToBlock(keyframes))]);
    }
    return `${this.opts.prefix || ""}animation-${animationName}`;
  }
};
var client_default = StyletronClient;

// node_modules/styletron-engine-monolithic/dist-browser-esm/server/server.js
var StyletronServer = class {
  constructor(opts = {}) {
    this.opts = opts || {};
    this.cache = {};
  }
  renderStyle(styles) {
    const className = hashCssObject(styles);
    if (!this.cache[className]) {
      this.cache[className] = injectStylePrefixed(styles, className, this.opts.prefix || "", Boolean(this.opts.strict)).join("");
    }
    return `${this.opts.prefix || ""}css-${className}`;
  }
  renderFontFace(fontFace) {
    const fontName = hashCssObject(fontFace);
    if (!this.cache[fontName]) {
      this.cache[fontName] = fontFaceBlockToRule(`${this.opts.prefix || ""}font-${fontName}`, declarationsToBlock(fontFace));
    }
    return `${this.opts.prefix || ""}font-${fontName}`;
  }
  renderKeyframes(keyframes) {
    const animationName = hashCssObject(keyframes);
    if (!this.cache[animationName]) {
      this.cache[animationName] = keyframesBlockToRule(`${this.opts.prefix || ""}animation-${animationName}`, keyframesToBlock(keyframes));
    }
    return `${this.opts.prefix || ""}animation-${animationName}`;
  }
  getStylesheets() {
    const hashedNames = [...Object.keys(this.cache)];
    return [{
      css: this.getCss(),
      attrs: {
        "data-hydrate": hashedNames.join(" ")
      }
    }];
  }
  getStylesheetsHtml(className = "_styletron_hydrate_") {
    return generateHtmlString(this.getStylesheets(), className);
  }
  getCss() {
    return [...Object.values(this.cache)].join("");
  }
};
function generateHtmlString(sheets, className) {
  let html = "";
  for (let i = 0; i < sheets.length; i++) {
    const sheet = sheets[i];
    const {
      class: originalClassName,
      ...rest
    } = sheet.attrs;
    const attrs = {
      class: originalClassName ? `${className} ${originalClassName}` : className,
      ...rest
    };
    html += `<style${attrsToString(attrs)}>${sheet.css}</style>`;
  }
  return html;
}
function attrsToString(attrs) {
  let result = "";
  for (const attr in attrs) {
    const value = attrs[attr];
    if (value === true) {
      result += " " + attr;
    } else if (value !== false) {
      result += ` ${attr}="${value}"`;
    }
  }
  return result;
}
var server_default = StyletronServer;
export {
  client_default as Client,
  server_default as Server
};
//# sourceMappingURL=styletron-engine-monolithic.js.map
